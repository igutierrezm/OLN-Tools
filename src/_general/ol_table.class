* Una clase para especificar todas las tablas del OLN/OLR
version 14.1
class ol_table {
  * Comandos
  string cmds
  string cmds_lb
  string cmds_fmt
  * Dominios
  string years
  string months
  string subpops
  string subpops_lb
  string by
  string along
  * Estructura
  string rowvar
  string colvar
  * Agregaciones
  string margins
  string margins0
  string margins_lb
  * I-O
  string src
  string from
  string varlist0
  string title
  * Campos auxiliares
  string over
  string fmts
  string varlist1
  double N_over
  double N_cmds
  double N_along
}

* Rellena todos los campos auxiliares de la tabla
capture program drop complete
program define .complete
  version 14.1
  syntax

  * Reinterpretación de todos los campos que usan llaves como delimitador
  local fields "cmds cmds_lb cmds_fmt subpops subpops_lb margins margins_lb"
  foreach symbol in "{" "}" {
    foreach field of local fields {
      .`field' = subinstr(`"`.`field''"', "`symbol'", `"""', .)
    }
  }

  * Expansión de los numlist years y months
  foreach field in months years {
    numlist "`.`field''"
    .`field' = "`r(numlist)'"
  }
  if inlist("`.src'", "casen", "esi") .months = ""

  * Dimensiones relevantes para el cuadro
  local fields "months years cmds subpops along by over margins"
  foreach field of local fields {
      .N_`field' = `:word count of `.`field''' - 1
  }

  * Cruces de agregaciones
  quietly : {
    drop _all
    set obs 2
    forvalues i = 1(1)`.N_margins' {
    	local var : word `i' of `.margins'
    	generate v`i' = ""
    	replace  v`i' = "`var'" in 2
    }
    capture : fillin *
    capture : drop _fillin
    egen margins_int = group(*), missing label lname(margins)
    decode margins, generate(margins_str)
    local margins = ""
    forvalues i = 2(1)`c(N)' {
      local margins = "`margins'" + " {" + margins_str[`i'] + "}"
    }
    .margins0 = "`margins'"
    foreach symbol in "{" "}" {
      .margins0 = subinstr(`"`.margins0'"', "`symbol'", `"""', .)
    }
    drop _all
  }

  * Campos auxiliares
  .varlist1 = `"`.varlist0' _counter _psu _estrato _pweight"'
  .over = "`.along' `.by'"

  * Valores por defecto
  if ("`.months'" == "") .months = "0"
end

* Carga la BBDD relevante para la tabla
capture program drop selectvars
program define .selectvars
  version 14.1
  syntax, año(string) mes(string)

  * Identificación de la base relevante
  local mes = string(`mes', "%02.0f")
  if ("`.src'" == "casen") local df "`.from'/CASEN/CASEN `año'"
  if ("`.src'" == "ene")   local df "`.from'/ENE/ENE `año' `mes'"
  if ("`.src'" == "esi")   local df "`.from'/ESI/ESI `año' Personas"
  if ("`.src'" == "sii")   local df "`.from'/SII/AC `año'"

  * Selección de las variables relevantes
  ol_select, varlist(`"`.varlist1'"') db("`.src'") año(`año') mes(`mes')
  use `r(selection)' using "`df'", clear
end

* Recupera las estadísticas (como variables), luego de usar el comando estimate
capture program drop get_stats
program define .get_stats
  version 14.1
  syntax, stat(string)
  * Objetos temporales
  tempname bh o2
  * Macros auxiliares
  if ("`stat'" == "proportion") local k = 100
  if ("`stat'" != "proportion") local k = 1
  * Estadísticas (como matrices)
  matrix `bh' = `k'^1 * e(b)'
  matrix `o2' = `k'^2 * vecdiag(e(V))'
  * Estadísticas (como variables)
  drop _all
  foreach var in bh o2 {
    svmat ``var'', names("`var'")
    rename `var'1 `var'
  }
  generate cv = 100 * abs(sqrt(o2) / bh)
end

* Anexa los dominios a las estadísticas recuperadas con .get.estimates
capture program drop get_domains
program define .get_domains
  version 14.1
  syntax, stat(string)
  * Despacho
  if ("`stat'" != "proportion") .get_domains_v1
  if ("`stat'" == "proportion") .get_domains_v2
end

* Versión N°1 de .get_domains (usar tras estimate total/mean/ratio)
capture program drop get_domains_v1
program define .get_domains_v1
  version 14.1
  syntax
  * Identificación de los dominios
  tempvar id
  if (`.N_over' >= 1) {
    * Creación de un id único
    generate `id' = ""
    forvalues i = 1(1)`c(N)' {
      local str : word `i' of `: colnames e(b)'
      if (`.N_over' == 1) replace `id' = "`str'" in `i'
      else {
        local str = subinstr("`str'", "_subpop_", "", 1)
        local str : word `str' of `e(over_labels)'
        replace `id' = "`str'" in `i'
      }
    }
    * Recuperación de los dominios originales
    split `id', generate(id)
    forvalues i = 1(1)`.N_over' {
      local name : word `i' of `.over'
      destring id`i', replace
      rename id`i' `name'
    }
  }
end
/* Esta función necesita limpieza */

* Versión N°2 de .get_domains (usar tras estimate proportion)
capture program drop get_domains_v2
program define .get_domains_v2
  version 14.1
  syntax
  * Macros auxiliares
  if (`.N_over' != 1) local prop_id : coleq    e(b)
  if (`.N_over' == 1) local prop_id : colnames e(b)
  * Identificación de los dominios
  tempvar id
  if (`.N_along' >= 1) {
    * Creación de un id único
    generate `id' = ""
    forvalues i = 1(1)`c(N)' {
      local str : word `i' of `: colnames e(b)'
      if (`.N_along' == 1) replace `id' = "`str'" in `i'
      else {
        local str = subinstr("`str'", "_subpop_", "", 1)
        local str : word `str' of `e(over_labels)'
        replace `id' = "`str'" in `i'
      }
    }
    * Recuperación de los dominios originales
    split `id', generate(id)
    forvalues i = 1(1)`.N_along' {
      local name : word `i' of `.over'
      destring id`i', replace
      rename id`i' `name'
    }
  }
  * Identificación de las proporciones
  generate `e(varlist)' = ""
  forvalues i = 1(1)`c(N)' {
    local str : word `i' of `prop_id'
    local str = subinstr("`str'", "_prop_", "", 1)
    local str : word `str' of `e(label1)'
    replace `e(varlist)' = "`str'" in `i'
  }
  destring `e(varlist)', replace
end
/* Esta función necesita limpieza */

* Limpia la tabla (la ordena, le agrega etiquetas, etc.)
capture program drop clean
program define .clean
  version 14.1
  syntax
  * Etiquetado (valores)
  foreach año in `.years' {
    label define año `año' "`año'", modify
  }
  foreach mes in `.months' {
    label define mes `mes' "`mes'", modify
  }
  forvalues i = 1(1)`.N_cmds' {
    local cmd_lb : word `i' of `.cmds_lb'
    gettoken cmd_cd cmd_lb : cmd_lb, parse(":")
    gettoken dots cmd_lb : cmd_lb
    label define cmd_lb `cmd_cd' "`cmd_lb'", modify
  }
  forvalues j = 1(1)`.N_subpops' {
    local subpop_lb : word `j' of `.subpops_lb'
    gettoken subpop_cd subpop_lb : subpop_lb, parse(":")
    gettoken dots subpop_lb : subpop_lb
    label define subpop_lb `subpop_cd' "`subpop_lb'", modify
  }
  foreach var in año mes cmd_lb subpop_lb {
    label values `var' `var'
  }
  local i = 1
  foreach var in `.margins' {
    local str : word `i' of `.margins_lb'
    label define `var' .z "`str'", modify
    local ++i
  }
  * Etiquetado (variables)
  capture : label variable año       "Año"
  capture : label variable mes       "Trimestre"
  capture : label variable cmd_type  "Tipo de indicador (e.g., total)"
  capture : label variable cmd_fmt   "Formato del indicador (e.g., %9.1f)"
  capture : label variable cmd_lb    "Descripción del indicador"
  capture : label variable subpop_lb "Etiqueta de la sub-población"
  capture : label variable n         "Tamaño del dominio (sin expandir)"
  capture : label variable bh        "Indicador"
  capture : label variable o2        "Varianza"
  capture : label variable cv        "Coeficiente de variación (%)"
  foreach var in `.over' {
    label values `var' `var'
    label variable `var' "`: variable label `var''"
  }
  *Etiquetado de los meses
  # delimit ;
    label define mes
      00 "No corresponde"
      01 "dic-feb"
      02 "ene-mar"
      03 "feb-abr"
      04 "mar-may"
      05 "abr-jun"
      06 "may-jul"
      07 "jun-ago"
      08 "jul-sep"
      09 "ago-oct"
      10 "sep-nov"
      11 "oct-dic"
      12 "nov-ene",
      modify;
  # delimit cr
  label values mes mes
  * Ordenación
  order año mes subpop_lb cmd_type cmd_fmt cmd_lb `.over'
  gsort año mes subpop_lb cmd_type cmd_fmt cmd_lb `.over'
end
/* Esta función necesita limpieza */

* Deduce los tamaños muestrales (sin expansión)
capture program drop sample_sizes
program define .sample_sizes
  version 14.1
  syntax
  ** Preámbulo
  clear
  .complete

  ** Cuerpo
  quietly : {
    tempfile df
    save `df', emptyok
    foreach año in `.years' {
      foreach mes in `.months' {
        * Selección
        capture : .selectvars, año("`año'") mes("`mes'")
        if (_rc != 0) continue
        generate n = 1

        * Mutación
        ol_generate,                ///
          varlist(`"`.varlist1'"')  ///
          from("`.from'")           ///
          db("`.src'")              ///
          año("`año'")              ///
          mes("`mes'")

        * Captura de lvar
        foreach var in `.over' {
          local lvar`var' : variable label `var'
        }

        * Estimación y anexión (en línea) de los resultados
        snapshot save
        if (`.margins0' == "") local margins0 `""""'
        if (`.margins0' != "") local margins0 `""" `.margins0'"'
        foreach vars in `margins0' {
          forvalues i = 1(1)`.N_cmds' {
            forvalues j = 1(1)`.N_subpops' {
              * BBDD original
              snapshot restore 1

              * Comando
              local cmd     : word `i' of `.cmds'
              local cmd_lb  : word `i' of `.cmds_lb'
              local cmd_fmt : word `i' of `.cmds_fmt'
              gettoken cmd_cd cmd_lb : cmd_lb, parse(":")

              * Sub-población
              local subpop    : word `j' of `.subpops'
              local subpop_lb : word `j' of `.subpops_lb'
              gettoken subpop_cd subpop_lb : subpop_lb, parse(":")
              generate subpop = 1 `subpop'

              * Agregaciones
              foreach var in `vars' {
                replace `var' = 0 if (subpop != 1)
                replace `var' = 1 if (subpop == 1)
              }

              * Estimación
              gettoken stat : cmd
              collapse (sum) n if (subpop == 1), by(`.over')

              * Eliminación de las categorías espúreas
              foreach var in `vars' {
                keep if `var' == 1
                replace `var' = .z
        			}

              * ID auxiliares
              generate cmd_type = "`stat'"
              generate cmd_fmt  = "`cmd_fmt'"
              generate año = `año'
              generate cmd_lb = `cmd_cd'
              generate subpop_lb = `subpop_cd'
              generate mes = 0
              if ("`.months'" != "") replace mes = `mes'

              * Ordenación
              order año mes `.over' cmd_type cmd_fmt cmd_lb subpop_lb n
              gsort año mes `.over' cmd_type cmd_fmt cmd_lb subpop_lb

          		* Anexión
          		append using `df'
          		save `df', replace
            }
          }
      	}
        snapshot erase _all
      }
    }

    ** Epílogo
    .clean
    foreach var in `.over' {
      label variable `var' "`lvar`var''"
    }
  }
end

* Crea la tabla especificada
capture program drop create
program define .create
  version 14.1
  syntax
  ** Preámbulo
  tempfile df0 df
  .sample_sizes
  quietly : save `df0', replace

  ** Cuerpo
  clear
  .complete
  quietly : {
    save `df', emptyok
    foreach año in `.years' {
      foreach mes in `.months' {
        * Selección
        capture : .selectvars, año("`año'") mes("`mes'")
        if (_rc != 0) continue

        * Mutación
        ol_generate,  ///
          varlist(`"`.varlist1'"') db("`.src'") año("`año'") mes("`mes'") from("`.from'")

        * Captura de lvar
        foreach var in `.over' {
          local lvar`var' : variable label `var'
        }
        * Diseño muestral
        svyset _psu [pw = _pweight], strata(_estrato) singleunit(certainty)

        * Estimación y anexión (en línea) de los resultados
        snapshot save
        if (`.margins0' == "") local margins0 `""""'
        if (`.margins0' != "") local margins0 `""" `.margins0'"'
        foreach vars in `margins0' {
          forvalues i = 1(1)`.N_cmds' {
            forvalues j = 1(1)`.N_subpops' {
              * BBDD original
              snapshot restore 1

              * Comando
              local cmd     : word `i' of `.cmds'
              local cmd_lb  : word `i' of `.cmds_lb'
              local cmd_fmt : word `i' of `.cmds_fmt'
              gettoken cmd_cd cmd_lb : cmd_lb, parse(":")

              * Sub-población
              local subpop    : word `j' of `.subpops'
              local subpop_lb : word `j' of `.subpops_lb'
              gettoken subpop_cd subpop_lb : subpop_lb, parse(":")
              generate subpop = 1 `subpop'

              * Agregaciones
              foreach var in `vars' {
                replace `var' = 0 if (subpop != 1)
        				replace `var' = 1 if (subpop == 1)
        			}

              * Estimación
              gettoken stat : cmd
              local test = ("`stat'" == "proportion")
              if (`test' == 1) local opts `"over(`.along', nolabel) nolabel missing"'
              if (`test' == 0) local opts `"over(`.over',  nolabel)"'
              svy, subpop(subpop) : `cmd', `opts' nolegend
              * display "svy, subpop(subpop) : `cmd', `opts' nolegend"
              * ereturn list

              * Conversión de los resultados en una BBDD
              .get_stats,   stat("`stat'")
              .get_domains, stat("`stat'")

              * Eliminación de las categorías espúreas
              foreach var in `vars' {
                keep if `var' == 1
                replace `var' = .z
        			}

              * ID auxiliares
              generate cmd_lb    = `cmd_cd'
              generate cmd_fmt   = "`cmd_fmt'"
              generate cmd_type  = "`stat'"
              generate subpop_lb = `subpop_cd'
              generate año       = `año'
              generate mes       = `mes'

              * Ordenación
              order año mes `.over' cmd_type cmd_fmt cmd_lb subpop_lb bh o2 cv
              gsort año mes `.over' cmd_type cmd_fmt cmd_lb subpop_lb

          		* Anexión
          		append using `df'
          		save `df', replace
            }
          }
      	}
        snapshot erase _all
      }
    }

    ** Epílogo
    merge 1:1 año mes `.over' cmd_type cmd_fmt cmd_lb subpop_lb using `df0', nogenerate
    .clean
    if ("`.months'" == "0") drop mes
    foreach var in `.over' {
      label variable `var' "`lvar`var''"
    }
  }
end

* Agrega los resultados trimestrales de una tabla previamente creada
capture program drop annualize
program define .annualize
  version 14.1
  syntax
  * Objetos temporales
  tempvar n1 n2
  * Agregación
  generate `n1' = bh
  local bylist "año cmd_type cmd_fmt cmd_lb subpop_lb `.along' `.by'"
  collapse (sum) bh (max) o2 (count) `n1' (sum) n, by("`bylist'")
  replace bh = bh / `n1' if  inlist(cmd_type, "mean", "ratio")
  replace bh = bh / 4    if !inlist(cmd_type, "mean", "ratio")
  generate cv = 100 * sqrt(o2) / bh
  replace n = n / 4
  * Etiquetado
  label variable bh "Estimado"
  label variable o2 "Varianza"
  label variable cv "Coeficiente de variación (%)"
  label variable n  "Tamaño del dominio (sin expandir)"
end

* Convierte totales en proporciones
capture program drop add_proportions
program define .add_proportions
  version 14.1
  syntax, cmd_fmt(string) [cmd_lb(string) replace]
  * Macros auxiliares y objetos temporales
  tempfile df
  tempvar total_bh

  * Muestra efectiva
  save `df', replace
  keep if (cmd_type == "total")

  * Destrucción de subtotales (como categorías) y reconstrucción como variables
  replace bh = . if (`.by' == .z)
  egen `total_bh' = total(bh), by(año cmd_lb subpop_lb `.along')

  * Cálculo de las proporciones
  replace bh = 100 * bh / `total_bh'
  replace bh = 100 if (bh == .)

  * Identificación de los nuevos indicadores
  replace cmd_type = "proportion"
  replace cmd_fmt  = "`cmd_fmt'"
  gettoken cmd_cd cmd_lb : cmd_lb, parse(":")
  gettoken dots   cmd_lb : cmd_lb
  replace cmd_lb = `cmd_cd'

  * Etiquetado
  label define cmd_lb `cmd_cd' "`cmd_lb'", modify

  * Anexión
  append using `df'
  if ("`replace'" == "replace") drop if (cmd_type == "total")
end
* Esta función puede ser mucho más robusta.
* En cuanto tenga tiempo, me gustaría añadir una opción que actúe de
* manera similar a un recode ...

capture program drop add_asterisks
program define .add_asterisks
  version 14.1
  syntax
  * Macros y objetos temporales
  tempvar id_aux n_aux test
  * Mutación
  unab all : _all
  local exceptions bh o2 cv n `.by'
  local over : list all - exceptions
  generate `id_aux' = _n
  generate `test' = inlist(cmd_type, "total", "proportion")
  bysort `over' : egen `n_aux' = total(n)
  replace n = `n_aux' if (`test' == 1)
  generate asterisk = "ᵃ"
  replace asterisk  = " " if (n >= 50) & (`test' == 1)
  replace asterisk  = " " if (n >= 50) & (`test' == 0) & (cv <= 25)
  sort `id_aux'
  * Etiquetado
  label variable asterisk "Agrega una ᵃ a los estimadores poco precisos"
end

* Exporta la tabla a Excel (aplicando el formato del manual)
capture program drop export_excel
program define .export_excel
  version 14.1
  syntax varlist, file(string) sheet(string)
  quietly : {
    *===========================================================================
    * Prólogo
    *===========================================================================
    * Hoja de destino
    local var "`varlist'"
    putexcel set "`file'", sheet("`sheet'", replace) modify
    local export_cmd `"export excel using "`file'", sheet("`sheet'") sheetmodify"'

    * Trucamiento de las variables
    if ("`varlist'" == "bh") {
      tempvar bh_aux1 bh_aux2
      tostring bh, generate(`bh_aux1') format(%15,0fc) force
      tostring bh, generate(`bh_aux2') format(%15,1fc) force
      drop bh
      generate bh = ""
      replace bh = `bh_aux1' if (cmd_fmt == "%15,0fc")
      replace bh = `bh_aux2' if (cmd_fmt == "%15,1fc")
      replace bh = bh + asterisk
    }

    * Conversión de los mvs a valores "inofensivos"
    foreach var of varlist _all {
      capture : confirm numeric variable `var'
      if (_rc != 0) | inlist("`var'", "n", "bh", "o2", "cv") continue
      summarize `var'
      local var_max = `r(max)'
      forvalues i = 1(1)26 {
        local letter : word `i' of `c(alpha)'
        local lb_val : label `var' .`letter'
        local new_val = ceil(`var_max' + `i')
        replace `var' = `new_val' if (`var' == .`letter')
        label define `var' `new_val' "`lb_val'", modify
      }
    }

    * Macros auxiliares
    local N_along  = `:word count of `.colvar'' - 1
    local N_rowvar = `:word count of `.rowvar'' - 1
    foreach var in `.rowvar' `.colvar' {
      quietly : inspect `var'
      local K`var' = r(N_unique)
    }

    *===========================================================================
    * Encabezado de columnas
    *===========================================================================

    * Identificación
    preserve
    bysort  `.colvar' : keep if (_n == 1)
    decode2 `.colvar', replace

    * Exportación
    local k = 2
    foreach var in `.colvar' {
      forvalues i = 1(1)`c(N)' {
        local j = `i' + `N_rowvar'
        local Y : word `j' of `c(ALPHA)'
        putexcel `Y'`k' = `var'[`i']
      }
      local ++k
    }

    *===========================================================================
    * Encabezados de filas
    *===========================================================================

    * Identificación
    restore, preserve
    bysort  `.rowvar' : keep if (_n == 1)
    decode2 `.rowvar', replace
    keep `.rowvar'

    * Exportación
    local i = 1
    foreach var in `.rowvar' {
      local lb : variable label `var'
      local A  : word `i' of `c(ALPHA)'
      putexcel `A'2 = "`lb'"
      local ++i
    }
    `export_cmd' cell("A`k'")

    *===========================================================================
    * Cuerpo de la tabla
    *===========================================================================

    * Identificación
    restore, preserve
    keep `.colvar' `.rowvar' `varlist'
    reshape2 `varlist', i(`.rowvar') j(`.colvar')
    drop `.rowvar'

    * Exportación
    local i = `N_rowvar' + 1
    local B : word `i' of `c(ALPHA)'
    `export_cmd' cell("`B'`k'")

    *===========================================================================
    * Exportación (formato)
    *===========================================================================

    * Marcadores de filas
    local N0 = 2
    local N1 = `k' - 1
    local N2 = `k' - 0
    local N3 = `c(N)' + `k' - 2
    local N4 = `c(N)' + `k' - 1

    * Marcadores de columnas
    local Ncols1 = `c(k)'
    local Ncols2 = `c(k)' + `N_rowvar'

    /* * Formato de número
    forvalues i = 1(1)`Ncols1' {
      local j = `i' + `N_rowvar'
    	local X : word `j' of `c(ALPHA)'
    	local fmt : word `i' of `fmts'
    	putexcel (`X'`N2':`X'`N4'), nformat("`fmt'")
    } */

    * Alineación
    local Z : word `Ncols2' of `c(ALPHA)'
    putexcel (B`N0':`Z'`N1'), hcenter
    putexcel (B`N2':`Z'`N4'), right

    * Fuente
    putexcel (A`N0':`Z'`N4'), font("Times New Roman", 11)

    * Color de relleno
    putexcel (A`N0':`Z'`N4'), fpattern(solid, white)

    * Combinación de celdas (encabezados de columnas)
    local i  = 2
    local Ni = 1
    local Di = `Ncols1'
    foreach var in `.colvar' {
      local Di = `Di' / `K`var''
      local Ni = `Ni' * `K`var''
      forvalues j = 1(1)`Ni' {
        local j0 = `N_rowvar' + 1 + `Di' * (`j' - 1)
        local j1 = `N_rowvar' - 0 + `Di' * (`j' - 0)
        local A : word `j0' of `c(ALPHA)'
        local B : word `j1' of `c(ALPHA)'
        putexcel (`A'`i':`B'`i'), merge hcenter
      }
      local ++i
    }
    local --i
    forvalues j = 1(1)`N_rowvar' {
      local A : word `j' of `c(ALPHA)'
      if (`i' > 2) putexcel (`A'2:`A'`i'), left merge
      else         putexcel (`A'2:`A'`i'), left
    }

    /*** No funciona si el tamaño de las celdas varía (lo arreglaré luego)
    * Combinación de celdas (encabezados de filas)
    local i  = 1
    local Ni = 1
    local Di = `c(N)'
    foreach var in `.rowvar' {
      local Di = `Di' / `K`var''
      local Ni = `Ni' * `K`var''
      local A : word `i' of `c(ALPHA)'
      display as error "A = `A', Di = `Di', Ni = `Ni'"
      forvalues j = 1(1)`Ni' {
        local j0 = `N2' - 0 + `Di' * (`j' - 1)
        local j1 = `N2' - 1 + `Di' * (`j' - 0)
        display as error "A = `A', j0 = `j0', j1 = `j1'"
        putexcel (`A'`j0':`A'`j1'), merge left vcenter
      }
      local ++i
    }
    ***/

    * Bordes (general)
    putexcel (A`N0':`Z'`N0'), border("top", "medium", "black")
    putexcel (A`N3':`Z'`N3'), border("bottom", "thin", "black")
    putexcel (A`N4':`Z'`N4'), border("bottom", "medium", "black")
    forvalues i = `N0'(1)`N1' {
      putexcel (A`i':`Z'`i'), border("bottom", "thin", "black")
    }

    * Título
    putexcel A1 = "`.title'", font("Times New Roman", 11) bold
  }
end
